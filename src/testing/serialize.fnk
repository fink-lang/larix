

get_comment = fn indent, comments:
  lines = comments.map fn {op, value}:
    match op:
      '#': '${indent}#${value}'
      else:
        lines = value.split '\n'
        prefixed = lines.map fn line: `${indent}--- ${line}`
        prefixed.join '\n'

  lines.join '\n'


trailing_comment = fn indent, node:
  match node:
    {comments: {trailing: {length: ? > 0}}}:
      comment = get_comment '${indent}', node.comments.trailing
      `\n${comment}`
    else: ''


str_type_op = fn {type, op, comments, loc: {start, end}}, indent:
  head = match true:
    (op && op != type):
      `${type} ${op} (${start.line}:${start.column}-${end.line}:${end.column})`
    else:
      `${type} (${start.line}:${start.column}-${end.line}:${end.column})`

  leading = match comments:
    {leading: {length: ? > 0}}:
      comment = get_comment '${indent}', comments.leading
      `${comment}\n`
    else:  ''

  '${leading}${indent}${head}'


serialize_block = fn node, serialize, indent:
  head = str_type_op node, indent
  exprs = node.exprs.map fn expr: serialize expr, `${indent}  `

  match node:
    {args: {}}:
      args = node.args.map fn expr: serialize expr, `${indent}  `

      arg_str = match args:
        {length: 0}: ':'
        else: `\n${args.join '\n'}\n${indent}  :`

      `${head}${arg_str}\n${exprs.join '\n'}`

    else:
      exprs = node.exprs.map fn expr: serialize expr, `${indent}  `
      `${head}\n${exprs.join '\n'}`


serialize_call = fn node, serialize, indent:
  head = str_type_op node, indent

  callee = serialize node.callee, `${indent}  `
  args = node.args.map fn expr: serialize expr, `${indent}  `
  arg_str = match args:
    ?.length > 0: `${args.join '\n'}`
    else: ''

  `${head}\n${callee}\n${arg_str}`


serialize_infix = fn node, serialize, indent:
  head = str_type_op node, indent

  left = serialize node.left, `${indent}  `
  right = serialize node.right, `${indent}  `

  `${head}\n${left}\n${right}`


serialize_prefix = fn node, serialize, indent:
  head = str_type_op node, indent
  right = serialize node.right, `${indent}  `
  `${head}\n${right}`


serialize_spread = fn node, serialize, indent:
  match node:
    {right: {}}: serialize_prefix node, serialize, indent
    else: str_type_op node, indent


serialize_str = fn node, serialize, indent:
  head = str_type_op node, indent

  tag = match node:
    {tag: {}}: ` ${node.tag.value}`
    else: ''

  [lne, ...lns] = pipe node.exprs:
    map part:
      match part.type:
        'string:text': `'${part.value}'`
        else:
          value = serialize part, '${indent}  '
          `\n${value}\n`

    fn [...items]: items.join ''
    fn str: str.split '\n'

  str = [lne, ...lns.map fn ln: `${indent}  ${ln}`].join '\n'

  `${head}\n${indent}  ${tag}${str}`


serialize_regex = fn node, serialize, indent:
  head = str_type_op node, indent
  `${head}\n${indent}  /${node.value}/${node.flags}`


serialize_other = fn node, serialize, indent:
  head = str_type_op node, indent
  `${head} ${node.value}`


serialize_jsx = fn node, serialize, indent:
  head = str_type_op node, indent

  match node:
    {type: 'jsx-elem'}:
      props = node.props.map fn expr: serialize expr, `${indent}  `
      children = node.children.map fn expr: serialize expr, `${indent}  `

      props_str = match props:
        ?.length > 0: `\n${props.join '\n'}`
        else: ''

      children_str = match children:
        ?.length > 0: `\n${indent}  :\n${children.join '\n'}`
        else: ''

      `${head} ${node.name}${props_str}${children_str}`

    {type: 'jsx-attr', value: {}}:
      value = serialize node.value, `${indent}  `
      `${head} ${node.name}\n${indent}  ${value}`

    {type: 'jsx-attr'}:
      `${head} ${node.name}`

    {type: 'jsx-text'}:
      `${head}\n${indent}  ${JSON.stringify node.value}`

    {type: 'jsx-string'}:
      `${head}\n${indent}  '${node.value}'`

    {type: 'jsx-expr-container'}:
      expr = serialize node.expr, `${indent}  `
      `${head}\n${expr}`


serialize = fn node, indent='':
  result = match node:
    {error: {}}:
      `${indent}::error::`

    {type: 'empty'}:
      str_type_op node, indent

    {type: 'string'}:
      serialize_str node, serialize, indent

    {type: 'call'}:
      serialize_call node, serialize, indent

    {type: 'regex'}:
      serialize_regex node, serialize, indent

    {type: 'spread'}:
      serialize_spread node, serialize, indent

    {type: ?.startsWith 'jsx-'}:
      serialize_jsx node, serialize, indent

    {left: {}, right: {}}:
      serialize_infix node, serialize, indent

    {right: {}}:
      serialize_prefix node, serialize, indent

    {exprs: {}}:
      serialize_block node, serialize, indent

    {value: {}}:
      serialize_other node, serialize, indent

    else:
      head = str_type_op node, indent
      `Error: cannot serialize ${head}`

  '${result}${trailing_comment '${indent}  ', node}'
