{
  next_is_end, curr_loc, next_loc, collect_text, advance, expression
} = import '@fink/prattler'

{next_is_unindented} = import '../indentation'

{symbol} = import '../symbols'


collect_comment = fn ctx, op:
  {start: {column: curr_col, line: curr_line}} = curr_loc:: ctx

  [text, next_ctx] = collect_text:: ctx, '\n'

  {start: {column: next_col, line: next_line}} = next_loc:: next_ctx
  {value: next_val} = next_ctx.next_token

  match next_ctx:
    {next_token: {value: '#'}}:
      [next_text, foo_ctx] = collect_comment:: advance(next_ctx), op
      loc = {start: text.loc.start, end: next_text.loc.end}
      [{...text, value: '${text.value}\n${next_text.value}', loc}, foo_ctx]
    else:
      [text, next_ctx]


comment = fn op:

  # TODO: trailing comments cause issues with precedence
  # lbp: fn lbp: fn ctx, left:
  #     {loc: {end}} = left
  #     {start} = next_loc:: ctx
  #     match start.line == end.line :
  #       true: 1
  #       else: 0
  #   ,
  # led: fn lbp: fn ctx, {comments, ...left}:
  #   [text, next_ctx] = collect_text:: ctx, '\n'
  #   comment = {...text, trailing: true}
  #   [{...left, comments: {...comments, trailing: comment}}, next_ctx]
  # ,

  {
    ...symbol(op),

    nud: fn: fn ctx:
      [text, expr_ctx] = collect_comment:: ctx, op

      match expr_ctx:
        next_is_end:: ?:
          {loc, value} = text
          [{type: 'comment', op, value, loc}, expr_ctx]

        next_is_unindented:: ?:
          {loc, value} = text
          [{type: 'comment', op, value, loc}, expr_ctx]

        else:
          # TODO: should lbp be really 0
          [{comments, ...expr}, next_ctx] = expression:: expr_ctx, 0
          # TODO: 'comment' is for backwards compat v4.x
          [{...expr, comment: text, comments: {...comments, leading: text}}, next_ctx]
  }
