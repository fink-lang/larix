{curr_is, curr_value, curr_loc} = import '@fink/prattler/parser.fnk'
{next_is, next_matches, next_is_end} = import '@fink/prattler/parser.fnk'
{advance_expected, advance, collect_text} = import '@fink/prattler/parser.fnk'
{is_empty} = import '@fink/std-lib/iter.fnk'
{rx} = import '@fink/std-lib/regex.fnk'

{prefix} = import '../symbols.fnk'
{terminated_block} = import '../block/init.fnk'
{single_expression} = import '../block/expr.fnk'
{get_unindented_text} = import '../literals/string.fnk'



jsx_expr_container = fn ctx:
  [block, next_ctx] = terminated_block ctx, '}'
  expr = {...block, type: 'block'}
  [{type: 'jsx:expr', expr, loc: expr.loc}, next_ctx]



jsx_txt = fn ctx:
  [{value: text, loc}, next_ctx] = collect_text ctx, rx"'</|[<{]"
  [{type: 'jsx:text', value: text, loc}, next_ctx]



get_children = fn ctx:
  [txt, next_ctx] = jsx_txt ctx
  txt_children = match txt:
    {value: ''}: []
    else: [txt]

  match next_ctx:
    curr_is ?, '<>':
      [expr, children_ctx] = jsx_frag next_ctx
      [children, end_ctx] = get_children children_ctx
      [[...txt_children, expr, ...children], end_ctx]

    curr_is ?, '<':
      [expr, children_ctx] = jsx_elem next_ctx
      [children, end_ctx] = get_children children_ctx
      [[...txt_children, expr, ...children], end_ctx]

    curr_is ?, '{':
      [expr, children_ctx] = jsx_expr_container next_ctx
      [children, end_ctx] = get_children children_ctx
      [[...txt_children, expr, ...children], end_ctx]

    curr_is ?, '</>':
      [txt_children, next_ctx]

    else:
      [txt_children, next_ctx]



jsx_body = fn name, ctx:
  [children, name_ctx] = get_children ctx

  end_ctx = advance_expected name_ctx, name
  [children, advance_expected end_ctx, '>']



jsx_string_val = fn ctx:
  {start} = curr_loc ctx
  op = curr_value ctx

  [{loc: {end}, ...str}, next_ctx] = get_unindented_text ctx, op

  [{...str, loc: {start, end}}, next_ctx]



jsx_attr_value = fn ctx:
  match ctx:
    next_is ?, '{':
      jsx_expr_container advance ctx

    next_matches ?, rx'[\'"]':
      jsx_string_val advance ctx

    else:
      # err_ctx = advance_expected ctx, '{', '"', "'"
      # [..., err] = err_ctx.errors
      # [err, err_ctx]
      single_expression {...ctx, jsx: true}, 0



jsx_attr = fn ctx:
  name = curr_value ctx
  {start} = curr_loc ctx

  [value, next_ctx] = match ctx:
    next_is ?, '=':
      [value, next_ctx] = jsx_attr_value advance ctx
      [{value}, next_ctx]

    else:
      # TODO: should we use identifier as value?
      [{}, ctx]

  {end} = curr_loc next_ctx
  [{type: 'jsx:attr', name, ...value, loc: {start, end}}, next_ctx]



jsx_spread_attr = fn ctx:
  {start} = curr_loc ctx
  [right, next_ctx] = single_expression {...ctx, jsx: true}, 0
  {end} = curr_loc next_ctx

  [{type: 'spread', op: '...', right, loc: {start, end}}, next_ctx]



done = true

jsx_props = fn ctx:
  [props, next_ctx] = pipe ctx:
    unfold prop_ctx:
      [prop, next_ctx] = match prop_ctx:
        next_is_end ?, '/>':
          [done, prop_ctx]

        next_is_end ?, '>':
          [done, prop_ctx]

        next_is ?, '...':
          jsx_spread_attr advance prop_ctx

        else:
          jsx_attr advance prop_ctx

      ([prop, next_ctx], next_ctx)

    while [prop]: prop != done

    fold [prop, next_ctx], [props]=[[]]:
      [[...props, prop], next_ctx]

  match props:
    is_empty ?: [props, ctx]
    else: [props, next_ctx]



body_or_end_elem = fn ctx, name:
  match ctx:
    next_is ?, '>':
      [children, next_ctx] = jsx_body name, advance ctx
      [false, children, next_ctx]
    else:
      [true, [], advance_expected ctx, '/>']



jsx_elem = fn ctx:
  {start} = curr_loc ctx

  elem_ctx = advance ctx
  name = curr_value elem_ctx

  [props, body_ctx] = jsx_props elem_ctx

  [self_closing, children, next_ctx] = body_or_end_elem body_ctx, name
  {end} = curr_loc next_ctx

  list:
    {type: 'jsx:elem', name, props, children, self_closing, loc: {start, end}}
    next_ctx



jsx_frag = fn ctx:
  {start} = curr_loc ctx
  [children, next_ctx] = get_children ctx
  {end} = curr_loc next_ctx

  list:
    {type: 'jsx:frag', children, loc: {start, end}}
    next_ctx



jsx_elem_or_fragment = fn ctx:
  match ctx:
    curr_is ?, '<>':
      jsx_frag ctx
    else:
      jsx_elem ctx



jsx = fn op:
  dict:
    ...prefix op

    nud: fn: fn ctx:
      jsx_elem_or_fragment ctx

