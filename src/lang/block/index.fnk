{
  assert_advance, advance, expression,
  next_is, next_is_end, curr_is, curr_loc, next_loc, curr_value
} = import '@fink/prattler'
{token_error} = import '@fink/prattler/errors'
{end_token} = import '@fink/prattler/tokenizer'
{add_separator, add_non_separating} = import '@fink/prattler/symbols'

{symbol} = import '../symbols'
{next_is_unindented, indentation, push_indentation, pop_indentation} = import '../indentation'
{collect_single_comment} = import '../comments/comment'


empty_op = fn {loc: {end}}:
  {type: 'empty', value: '', loc: {start: end, end}}


next_is_indented_nl = fn ctx:
  curr_ind = indentation:: ctx
  {end: {line: curr_line}} = curr_loc:: ctx
  {start: {line: next_line, column: next_ind}} = next_loc:: ctx

  curr_line < next_line && curr_ind < next_ind


pop_block = fn prev_ind: fn ctx:
  {blocks: [end_symbol, ...blocks]} = ctx

  match ctx:
    next_is:: ?, end_symbol:
      ind_ctx = {...ctx, blocks}
      next_ctx = pop_indentation:: ind_ctx, prev_ind
      assert_advance:: next_ctx, end_symbol

    # next_is_unindented:: ?:
    # next_is_end:: ?:
    else:
      throw token_error::
        `Expected ',' or indented new line or '${end_symbol}'.`
        ctx.next_token
        ctx


pop_block_no_end = fn prev_ind: fn ctx:
  next_ctx = pop_indentation:: ctx, prev_ind

  match next_ctx:
    next_is_end:: ?: advance:: next_ctx
    else: next_ctx


push_block = fn ctx, end_symbol:
  {blocks=[]} = ctx
  curr_ind = indentation:: ctx

  ind_ctx = match end_symbol:
    end_token: ctx
    else: push_indentation:: ctx, curr_ind + 1

  match end_symbol:
    end_token:
      pop = pop_block_no_end:: curr_ind
      [pop, {...ind_ctx, blocks}]
    # TODO: should be bock_end
    null:
      pop = pop_block_no_end:: curr_ind
      [pop, {...ind_ctx, blocks}]
    else:
      pop = pop_block:: curr_ind
      [pop, {...ind_ctx, blocks: [end_symbol, ...blocks]}]


next_is_end_of_block = fn ctx:
  {blocks: [end_symbol]} = ctx

  match ctx:
    next_is_end:: ?, end_symbol: true
    next_is_unindented:: ?: true
    # TODO: should be responsibility of enclosing block
    next_is:: ?, ':': true
    else: false


next_is_nl = fn ctx:
  {end: {line: curr_line}} = curr_loc:: ctx
  {start: {line: next_line}} = next_loc:: ctx
  curr_line < next_line


get_all = fn ctx, single_expr:

  [exprs, next_ctx] = pipe [ctx, [], true, false]:
    unfold [ctx, exprs, at_start, was_comma]:
      [next_exprs, next_ctx, done, next_at_start, next_was_comma] = match ctx:
        next_is_end_of_block:: ?:
          match was_comma:
            true:
              expr = empty_op:: ctx.curr_token
              [[...exprs, expr], ctx, true]
            else:
              [exprs, ctx, true]

        next_is_indented_nl:: ?:
          {start: {column: block_ind}} = next_loc:: ctx
          block_ctx = push_indentation:: ctx, block_ind
          [exprs, block_ctx, false, true, was_comma]

        next_is:: ?, ',':
          next_ctx = advance:: ctx

          match at_start:
            true:
              expr = empty_op:: ctx.next_token
              match was_comma:
                true:
                  expr0 = empty_op:: ctx.curr_token
                  [[...exprs, expr0, expr], next_ctx, false, true, false]
                else:
                  [[...exprs, expr], next_ctx, false, true, false]
            else:

              [exprs, next_ctx, false, true, true]
        else:
          match at_start:
            false:
              # TODO: use curr block's end symbol
              throw token_error::
                `Expected ',' or indented new line or end of block.`
                ctx.next_token
                ctx

          # TODO: check if next is actially a start of an expr.
          [expr, next_ctx] = single_expr:: ctx
          # new line at end of expr is a separator
          next_is_start = match true:
            next_is_nl:: next_ctx:
              true
            else:
              ---
              TODO: collect_text might have and issue incorrect text loc
              and not advancing ignorable tokens.
              This causes issues with end of block comments
              ```
                match:
                  shrub
                  # block comment
                foobar
              ```
              ---
              next_ctx.curr_token.value == '\n'

          [[...exprs, expr], next_ctx, false, next_is_start, false]

      (
        [next_exprs, next_ctx, done],
        [next_ctx, next_exprs, next_at_start, next_was_comma]
      )

    find [exprs, ctx, done]: done


expressions = fn ctx, end_symbol, single_expr:
  {start} = curr_loc:: ctx

  [pop_block, block_ctx] = push_block:: ctx, end_symbol

  [all_exprs, next_ctx] = get_all:: block_ctx, single_expr

  [exprs, comments] = pipe all_exprs:
    fold expr, [exprs]=[[]]:
      match expr:
        {type: 'comment'}:
          {exprs: trailing} = expr
          [exprs, {trailing}]
        else:
          [[...exprs, expr], {}]

  end_ctx = pop_block:: next_ctx

  {end} = curr_loc:: end_ctx
  [{type: 'exprs', exprs, comments, loc: {start, end}}, end_ctx]


single_expression = fn ctx, lbp=0:
  [expr, next_ctx] = expression:: ctx, lbp

  match next_ctx:
    next_is_nl:: ?:
      [expr, next_ctx]

    next_is:: ?, '#':
      comment_ctx = advance:: next_ctx
      [item, expr_ctx] = collect_single_comment:: comment_ctx, '#'
      comments = {...expr.comments, trailing: [item]}
      [{...expr, comments}, expr_ctx]
    else:
      [expr, next_ctx]


terminated_block = fn ctx, end_symbol, block_expr=single_expression:
  expressions:: ctx, end_symbol, block_expr


indented_block = fn ctx, block_expr=single_expression:
  # TODO: null should be bock_end
  terminated_block:: ctx, null, block_expr


named_block = fn op, type, block_expr:
  nud = fn: fn ctx:
    {start} = curr_loc:: ctx

    [{exprs: args}, body_ctx] = terminated_block:: ctx, ':'
    [{exprs, comments, loc}, next_ctx] = indented_block:: body_ctx, block_expr
    [{type, op, args, exprs, comments, loc: {start, end: loc.end}}, next_ctx]

  {...symbol(op), nud}


add_named_block = fn op, type='block', block_expr=single_expression: fn ctx:
   pipe ctx:
    add_non_separating:: named_block:: op, type, block_expr
    add_separator:: symbol:: ':'

