{advance, expression, next_is, next_is_end, curr_loc, next_loc} = import '@fink/prattler'
{token_error} = import '@fink/prattler/errors'
{end_token} = import '@fink/prattler/tokenizer'
{add_separator, add_non_separating} = import '@fink/prattler/symbols'

{symbol} = import '../symbols'
{collect_single_comment} = import '../comments/collect'

{curr_indentation, update_indentation, push_block, pop_block} = import './indentation'
{end_of_block_indent, next_is_unindented, next_is_indented} = import './indentation'


empty_op = fn {loc: {end}}:
  {type: 'empty', value: '', loc: {start: end, end}}


get_end_symb = fn {blocks: [block, ...blocks]}:
  match block:
    {end_symbol: end_of_block_indent}: get_end_symb:: {blocks}
    else: block.end_symbol


next_is_end_of_block = fn ctx:
  end_symbol = get_end_symb:: ctx

  match ctx:
    next_is_end:: ?, end_symbol: true
    next_is_unindented:: ?: true
    # TODO: should be responsibility of enclosing block
    next_is:: ?, ':': true
    else: false


next_is_nl = fn ctx:
  {end: {line: curr_line}} = curr_loc:: ctx
  {start: {line: next_line}} = next_loc:: ctx
  curr_line < next_line


get_all = fn ctx, single_expr:
  pipe [[], ctx, true, false]:
    unfold [exprs, ctx, at_start, was_comma]:
      [done, next] = match ctx:
        next_is_indented:: ?:
          next_ctx = update_indentation:: ctx
          [false, [exprs, next_ctx, true, was_comma]]

        next_is_end_of_block:: ?:
          match was_comma:
            true:
              expr = empty_op:: ctx.curr_token
              [true, [[...exprs, expr], ctx]]
            else:
              [true, [exprs, ctx]]

        next_is:: ?, ',':
          next_ctx = advance:: ctx

          match at_start:
            true:
              expr = empty_op:: ctx.next_token
              match was_comma:
                true:
                  expr0 = empty_op:: ctx.curr_token
                  [false, [[...exprs, expr0, expr], next_ctx, true, false]]
                else:
                  [false, [[...exprs, expr], next_ctx, true, false]]
            else:

              [false, [exprs, next_ctx, true, true]]
        else:
          match at_start:
            false:
              # TODO: use curr block's end symbol
              throw token_error::
                `Expected ',' or indented new line or '${get_end_symb:: ctx}'.`
                ctx.next_token
                ctx

          # TODO: check if next is actially a start of an expr.
          [expr, next_ctx] = single_expr:: ctx
          # new line at end of expr is a separator
          next_is_start = next_is_nl:: next_ctx

          [false, [[...exprs, expr], next_ctx, next_is_start, false]]

      ([done, next], next)

    find [done]: done

    fn [, [exprs, next_ctx]]:
      [exprs, next_ctx]


expressions = fn ctx, end_symbol, single_expr:
  {start} = curr_loc:: ctx

  block_ctx = push_block:: ctx, end_symbol

  [all_exprs, next_ctx] = get_all:: block_ctx, single_expr

  [exprs, comments] = pipe all_exprs:
    fold expr, [exprs]=[[]]:
      match expr:
        {type: 'comment'}:
          {exprs: trailing} = expr
          [exprs, {trailing}]
        else:
          [[...exprs, expr], {}]

  end_ctx = pop_block:: next_ctx

  {end} = curr_loc:: end_ctx
  [{type: 'exprs', exprs, comments, loc: {start, end}}, end_ctx]


single_expression = fn ctx, lbp=0:
  [expr, next_ctx] = expression:: ctx, lbp

  match next_ctx:
    next_is_nl:: ?:
      [expr, next_ctx]

    next_is:: ?, '#':
      comment_ctx = advance:: next_ctx
      [item, expr_ctx] = collect_single_comment:: comment_ctx, '#'
      comments = {...expr.comments, trailing: [item]}
      [{...expr, comments}, expr_ctx]

    else:
      [expr, next_ctx]


terminated_block = fn ctx, end_symbol, block_expr=single_expression:
  expressions:: ctx, end_symbol, block_expr


indented_block = fn ctx, block_expr=single_expression:
  terminated_block:: ctx, end_of_block_indent, block_expr


named_block = fn op, type, block_expr:
  nud = fn: fn ctx:
    {start} = curr_loc:: ctx

    [{exprs: args}, body_ctx] = terminated_block:: ctx, ':'
    [{exprs, comments, loc}, next_ctx] = indented_block:: body_ctx, block_expr
    [{type, op, args, exprs, comments, loc: {start, end: loc.end}}, next_ctx]

  {...symbol(op), nud}


add_named_block = fn op, type='block', block_expr=single_expression: fn ctx:
   pipe ctx:
    add_non_separating:: named_block:: op, type, block_expr
    add_separator:: symbol:: ':'


init_indentation = fn ctx:
  {...ctx, blocks: [{end_symbol: end_token, min_ind: 0, curr_ind: 0}]}
