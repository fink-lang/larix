{
  next_is, next_matches, expression, curr_loc, curr_value, advance,
  assert_next, next_value
} = import '@fink/prattler'
{token_error} = import '@fink/prattler/errors'

{symbol} = import '../symbols'
{seq} = import '../generic/sequence'


value_expr = fn ctx, key:
  match ctx:
    next_is:: ?, ':':
      expression:: ctx, 0
    else:
      [key, ctx]


key_expr = fn ctx:
  [key, next_ctx] = expression:: ctx, 0
  match key:
    # TODO: add support for ? in [...] operator all match fall through
    {type: 'group'}: [key, next_ctx]
    {type: 'assign'}: [key, next_ctx]
    {type: 'ident'}: [key, next_ctx]
    {type: 'string'}: [key, next_ctx]
    {type: 'spread'}: [key, next_ctx]
    else:
      throw token_error::
        `Expected prop-key but found '${key.type}' expression.`
        ctx.next_token
        ctx


prop_expr = fn ctx:
  [key_or_default, value_ctx] = key_expr:: ctx
  [value, next_ctx] = value_expr:: value_ctx, key_or_default

  key = match key_or_default.type:
    'assign': key_or_default.left
    else: key_or_default

  {start} = key.loc
  {end} = value.loc

  # TODO: should `key, value` just be `left, right` to simplify matters
  [{type: 'prop', key, value, loc: {start, end}}, next_ctx]


object = fn op:
  {
    ...symbol(op),

    nud: fn: fn ctx:
      {start} = curr_loc:: ctx
      [exprs, next_ctx] = seq:: ctx, '}', prop_expr
      {end} = curr_loc:: next_ctx

      [{type: 'object', exprs, loc: {start, end}}, next_ctx]
  }
