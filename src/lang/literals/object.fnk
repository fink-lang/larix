{next_is, next_matches, has_errors, advance} = import '@fink/prattler'
{curr_loc, curr_value} = import '@fink/prattler'
{add_error} = import '@fink/prattler/errors'
{add_operator, add_separator} = import '@fink/prattler/symbols'
{rx} = import '@fink/std-lib/regex'

{prefix, terminator} = import '../symbols'
{terminated_block, add_named_block} = import '../block'
{single_expression} = import '../block/expr'


next_is_key = fn ctx:
  {next_token: {value}} = ctx
  match ctx:
    next_matches ?, rx'^[0-9].*': false
    # TODO is this not covered by the else part?
    # TODO should we use unicode [\p{L}\p{N}_]+
    # TODO ident allows everything expect numbers, should this be the same?
    next_matches ?, rx'^\w+$': true
    # TODO: prattler internal
    {tokenizer: {tokens: {(value): {}}}}: false
    else: true


value_expr = fn ctx, key:
  match ctx:
    next_is ?, ':':
      next_ctx = advance ctx
      single_expression next_ctx, 0
    else:
      [key, ctx]


default_assignment = fn ctx, left:
  expr_ctx = advance ctx

  [right, next_ctx] = single_expression expr_ctx, 0
  {loc: {end}} = right

  [{type: 'assign', op: '=', left, right, loc: {...left.loc, end}}, next_ctx]


key_expr = fn ctx:
  match ctx:
    next_matches ?, rx'^[`\'"(#]|\.\.\.|---$':
      single_expression ctx, 0

    next_is_key ?:
      key_ctx = advance ctx
      loc = curr_loc key_ctx
      value = curr_value key_ctx
      key = {type: 'ident', value, loc}

      match key_ctx:
        next_is ?, '=':
          default_assignment key_ctx, key
        else:
          [key, key_ctx]

    else:
      add_error ctx,
        `Expected prop-key but found '${ctx.next_token.value}'.`
        ctx.next_token



get_prop = fn ctx, key_or_default:
  match ctx:
    has_errors ?:
      left = key_or_default
      [left, ctx]

    else:
      [value, next_ctx] = value_expr ctx, key_or_default

      key = match key_or_default.type:
        'assign': key_or_default.left
        else: key_or_default

      {start} = key.loc
      {end} = value.loc

      [{type: 'object:prop', left: key, right: value, loc: {start, end}}, next_ctx]



prop_expr = fn ctx:
  [key_or_default, value_ctx] = key_expr ctx

  match key_or_default:
    {type: 'comment'}:
      [key_or_default, value_ctx]
    else:
      get_prop value_ctx, key_or_default



object = fn op:
  dict:
    ...prefix op

    nud: fn: fn ctx:
      # {start} = curr_loc ctx
      [{exprs, loc}, next_ctx] = terminated_block ctx, '}', prop_expr

      [{type: 'object', exprs, loc}, next_ctx]



add_object = fn ctx:
  pipe ctx:
    add_operator object '{'
    add_separator terminator ','
    add_separator terminator ':'
    add_separator terminator '}'

    add_named_block 'dict', 'object', prop_expr
