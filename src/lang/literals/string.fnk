{collect_text, curr_loc, next_loc} = import '@fink/prattler'
{curr_value, advance_expected} = import '@fink/prattler'
{add_operator} = import '@fink/prattler/symbols'

{rx, match_all, replace_all} = import '@fink/std-lib/regex'
{starts_with, slice} = import '@fink/std-lib/str'
{length} = import '@fink/std-lib/iter'
{min} = import '@fink/std-lib/math'
{max_int} = import '@fink/std-lib/num'

{prefix} = import '../symbols'

{terminated_block} = import '../block'
{next_is_new_expr, curr_indentation} = import '../block/indentation'


is_even = ? % 2 == 0


curr_next_adjecent = fn ctx:
  curr = curr_loc ctx
  next = next_loc ctx

  curr.end.line == next.start.line and curr.end.column == next.start.column


get_expr_part = fn ctx:
  expr_ctx = advance_expected ctx, '{'
  [block, next_ctx] = terminated_block expr_ctx, '}'

  match block:
    {exprs: 1 < length ?}:
      [{...block, type: 'block'}, next_ctx]
    else:
      {exprs: [expr]} = block
      [expr, next_ctx]


get_str_part = fn ctx, op:
  [{value: text, loc: {start, end}}, next_ctx] = match op:
    '"': collect_text ctx, rx'"|\$\{'
    else: collect_text ctx, rx"'|\$\{"

  [[escaped]] = match_all text, rx'\\*$'

  match escaped:
    is_even length ?:
      [{type: 'string:text', value: text, loc: {start, end}}, next_ctx]

    else:
      stop_value = curr_value next_ctx
      [str_part, final_ctx] = get_str_part next_ctx, op

      value = '${text}${stop_value}${str_part.value}'
      {end} = str_part.loc

      [{type: 'string:text', value, loc: {start, end}}, final_ctx]


get_parts = fn ctx, op:
  [str_part, next_ctx] = get_str_part ctx, op
  match curr_value next_ctx:
    '$':
      [expr_part, parts_ctx] = get_expr_part next_ctx
      [parts, final_ctx] = get_parts parts_ctx, op
      [[str_part, expr_part, ...parts], final_ctx]
    else:
      [[str_part], next_ctx]


get_str_ind = fn str, min_ind:
  matched = match_all str, rx'\n([ ]{${min_ind},})'
  pipe matched:
    map [, spaces]: length spaces


get_unindent = fn ctx, parts:
  min_ind = 1 + curr_indentation ctx

  ind = pipe parts:
    filter part:
      match part:
        {type: 'string:text'}: true
        else: false

    map part:
      ...get_str_ind part.value, min_ind

    min max_int, ...?


  fn str: replace_all str, rx'\n[ ]{0,${ind}}', '\n'


get_unindented_text = fn ctx, op:
  {start} = curr_loc ctx

  [parts, next_ctx] = get_parts ctx, op

  unindent = get_unindent ctx, parts

  [first, ...rest] = pipe parts:
    map part:
      match part:
        {type: 'string:text'}:
          value = unindent part.value
          {...part, value}
        else:
          part

  # remove first empty line
  exprs = match first.value:
    starts_with ?, '\n':
      [{...first, value: slice first.value, 1}, ...rest]
    else:
      [first, ...rest]

  {end} = curr_loc next_ctx
  [{type: 'string', op, exprs, loc: {start, end}}, next_ctx]


string = fn op:
  dict:
    ...prefix op

    lbp: fn lbp: fn ctx, left:
      match true:
        # default indentation behaviour
        next_is_new_expr ctx: 0
        left.type == 'ident' and curr_next_adjecent ctx: lbp
        else: 0

    led: fn: fn ctx, left:
      {loc: {start}} = left

      [{loc: {end}, ...str}, next_ctx] = get_unindented_text ctx, op

      # TODO: use `left` rather than `tag`?
      [{...str, tag: left, loc: {start, end}}, next_ctx]

    nud: fn: fn ctx:
      get_unindented_text ctx, op


add_string = fn ctx:
  pipe ctx:
    add_operator string "'"
    add_operator string '"'
