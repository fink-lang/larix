{advance, has_errors, collect_text} = import '@fink/prattler'
{next_matches, next_loc} = import '@fink/prattler'
{curr_value, curr_loc} = import '@fink/prattler'
{add_operator} = import '@fink/prattler/symbols'

{join, length} = import '@fink/std-lib/iter'
{starts_with, slice} = import '@fink/std-lib/str'
{match_all, split} = import '@fink/std-lib/regex'

{prefix} = import '../symbols'


is_even = ? % 2 == 0


curr_next_adjecent = fn ctx:
  curr = curr_loc ctx
  next = next_loc ctx

  curr.end.line == next.start.line and curr.end.column == next.start.column


unindent_text = fn text, ind:
  [first, ...rest] = split text, rx/\n/

  pipe rest:
    map line:
      slice line, ind
    [first, ...?]
    join '\n'


get_text = fn ctx, op:
  [{value: text, loc: {start, end}}, next_ctx] = collect_text ctx, op

  [[escaped]] = match_all text, rx/\\*$/

  match escaped:
    is_even length ?:
      [{text, loc: {start, end}}, next_ctx]
    else:
      [{text: new_text, loc: {end}}, final_ctx] = get_text next_ctx, op
      [{text: `${text}${op}${new_text}`, loc: {start, end}}, final_ctx]


next_is_flag = fn ctx:
  could_be_flag = curr_next_adjecent ctx
  could_be_flag and next_matches ctx, rx/[gimsuy]/


get_flags = fn ctx:
  match ctx:
    has_errors ?:
      ['', ctx]

    next_is_flag ?:
      next_ctx = advance ctx
      flags = curr_value next_ctx
      [flags, next_ctx]

    else:
      ['', ctx]


regex = fn op:
  dict:
    ...prefix op

    nud: fn: fn ctx:
      {start} = curr_loc ctx

      [{text}, flags_ctx] = get_text ctx, '/'

      pattern = match text:
        starts_with ?, '\n':
          [[ ,spaces]] = match_all text, rx/^\n+(\s+)/
          ind = spaces.length
          unindent_text
            slice text, 1 + ind
            ind
        else:
          text

      [flags, end_ctx] = get_flags flags_ctx

      {end} = curr_loc end_ctx
      # TODO: use `right` instead of flags?
      [{type: 'regex', value: pattern, flags, loc: {start, end}}, end_ctx]


add_regex = fn ctx:
  pipe ctx:
    add_operator regex 'rx/'
