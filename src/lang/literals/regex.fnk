{assert_advance, advance, collect_text} = import '@fink/prattler'
{next_is, next_is_end, next_matches, next_loc} = import '@fink/prattler'
{curr_is, curr_value, curr_loc} = import '@fink/prattler'

{unindent_text} = import '../../string-utils'
{symbol} = import '../symbols'
{get_next_line_indentation, curr_next_adjecent} = import '../indentation'


get_text = fn ctx, op:
  [{text, loc: {start, end}}, next_ctx] = collect_text(ctx, op)

  # TODO: previous larix version has a bug to terminate regex at $
  [escaped] = text.match(rx/\\*\\$/) || ['']

  match true:
    escaped.length % 2 == 0:
      [{text, loc: {start, end}}, next_ctx]
    else:
      [{text: new_text, loc: {end}}, final_ctx] = get_text(next_ctx, op)
      [{text: `${text}${op}${new_text}`, loc: {start, end}}, final_ctx]


get_flags = fn ctx:
  match true:
    (curr_next_adjecent(ctx) && next_matches(ctx, rx/[gimsuy]/)):
      next_ctx = advance(ctx)
      flags = curr_value(next_ctx)
      [flags, next_ctx]
    else:
      ['', ctx]


regex = fn op:
  {
    ...symbol(op),

    nud: fn: fn ctx:
      {start} = curr_loc(ctx)
      ind = get_next_line_indentation(ctx)

      [text, flags_ctx] = get_text(ctx, '/')
      pattern = unindent_text(text.text, ind)
      [flags, end_ctx] = get_flags(flags_ctx)

      {end} = curr_loc(end_ctx)
      [{type: 'regex', pattern, flags, loc: {start, end}}, end_ctx]
  }

