{advance, collect_text} = import '@fink/prattler'
{next_is, next_is_end, next_matches, next_loc} = import '@fink/prattler'
{curr_value, curr_loc} = import '@fink/prattler'
{add_operator, add_separator} = import '@fink/prattler/symbols'

{unindent_text} = import '../../string-utils'
{prefix} = import '../symbols'


curr_next_adjecent = fn ctx:
  curr = curr_loc ctx
  next = next_loc ctx

  curr.end.line == next.start.line && curr.end.column == next.start.column


get_text = fn ctx, op:
  [{value: text, loc: {start, end}}, next_ctx] = collect_text ctx, op

  [escaped] = text.match rx/\\*$/

  match true:
    escaped.length % 2 == 0:
      [{text, loc: {start, end}}, next_ctx]
    else:
      [{text: new_text, loc: {end}}, final_ctx] = get_text next_ctx, op
      [{text: `${text}${op}${new_text}`, loc: {start, end}}, final_ctx]


get_flags = fn ctx:
  could_be_flag = curr_next_adjecent ctx

  match true:
    could_be_flag && next_matches ctx, rx/[gimsuy]/:
      next_ctx = advance ctx
      # TODO use next_value ctx
      flags = curr_value next_ctx
      [flags, next_ctx]
    else:
      ['', ctx]


regex = fn op:
  {
    ...prefix op

    nud: fn: fn ctx:
      {start} = curr_loc ctx

      [{text}, flags_ctx] = get_text ctx, '/'

      pattern = match text:
        ?.startsWith '\n':
          [, spaces] = text.match rx/^\n+(\s+)/
          ind = spaces.length
          unindent_text
            text.slice 1 + ind
            ind
        else:
          text

      [flags, end_ctx] = get_flags flags_ctx

      {end} = curr_loc end_ctx
      # TODO: use `right` instead of flags?
      [{type: 'regex', value: pattern, flags, loc: {start, end}}, end_ctx]
  }


add_regex = fn ctx:
  pipe ctx:
    add_operator regex 'rx/'
